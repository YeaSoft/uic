#!/bin/bash
#
# (c) 2012 YeaSoft Int'l - Leo Moll
#
# VERSION 20120331
# function collection for the netpoldo development system

#####################
# Internal Variables
# generic script helpers
SCRIPTNAME=$(basename $0)
SCRIPTPATH=$(expr match "$0" '\(.*\)'\/$SCRIPTNAME)
VERBOSE=0
# uic specific
VERSION='@VERSION@'
SPECIALFSM="/sys /proc /dev /dev/pts /dev/shm"
SPECIALFSU="/dev/shm /dev/pts /dev /proc /sys"
SPECIALFSMOUNT=0
OLDHOSTNAME=$(hostname)
TARGET=

########################
# Overall default values

# The default working directory for installations
# Default: UIC_WORKDIR=/usr/src
UIC_WORKDIR=/usr/src

# The default APT proxy to use
# Default: none
UIC_APTPROXY=

# The default UIC template repositories
UIC_REPOSITORIES=http://www.yeasoft.com/uic-templates

#####################
# Functions

# generic script helpers

function show_name {
	echo "$SCRIPTNAME, version $VERSION"
}

function show_verbose {
	if [ $VERBOSE -ge $1 ]; then
		echo "$SCRIPTNAME: ${*:2}"
	fi
}

function show_warning {
	echo "$SCRIPTNAME warning: $*" >&2
}

function show_error {
	echo "$SCRIPTNAME error: $*" >&2
}

function test_exec {
	case $? in
	0);;
	*)	case "$1" in
		"")	show_error "last command failed with error (code $?)";;
		*)	show_error "$1 failed with error (code $?)";;
		esac
		if [ -n "$2" ]; then
			show_error "commandline: ${*:2}"
		fi
		exit $?;;
	esac
}

function test_getopt {
	case $? in
	0);;
	1) show_error "syntax or usage error (code $?)"; exit $?;;
	2) show_error "syntax or usage error (code $?) in [getopt]"; exit $?;;
	3) show_error "internal error (code $?) in [getopt]"; exit $?;;
	4) show_error "wrong getopt version installed"; exit $?;;
	*) show_error "unknown getopt error (code $?)"; exit $?;;
	esac
}

# uic specific

function init_script() {
	trap cleanup_script INT QUIT TERM EXIT
        call_hook init_script
}

function cleanup_script() {
        trap - INT QUIT TERM EXIT
        call_hook exit_script
        chroot_exit
        cleanup_mounts
}


function chroot_init() {
	if [ $SPECIALFSMOUNT -lt 1 ]; then
		show_verbose 1 "Mounting special file systems in environment..."
		mount_special
		enable_policy
		SPECIALFSMOUNT=1
	fi
}

function mount_special() {
	for MOUNT_POINT in $SPECIALFSM; do
		if ! grep "${TARGET}/chroot${MOUNT_POINT}" /proc/mounts > /dev/null; then
			mount -o bind ${MOUNT_POINT} ${TARGET}/chroot${MOUNT_POINT}
		fi
	done
}

function enable_policy() {
	echo -e "#!/bin/sh\nexit 101" > "${TARGET}/chroot/usr/sbin/policy-rc.d"
	chmod +x "${TARGET}/chroot/usr/sbin/policy-rc.d"
}

function disable_policy() {
	[ -f "${TARGET}/chroot/usr/sbin/policy-rc.d" ] && rm "${TARGET}/chroot/usr/sbin/policy-rc.d"
}

function umount_special() {
	for MOUNT_POINT in $SPECIALFSU; do
		if grep "${TARGET}/chroot${MOUNT_POINT}" /proc/mounts > /dev/null; then
			umount ${TARGET}/chroot${MOUNT_POINT}
		fi
	done
}

function chroot_exit() {
	if [ $SPECIALFSMOUNT -gt 0 ]; then
		show_verbose 1 "Unmounting special file systems in environment..."
		disable_policy
		umount_special 2> /dev/null
		SPECIALFSMOUNT=0
	fi
}

function test_mountinuse() {
	if grep "${TARGET}/chroot" /proc/mounts; then
		show_error "WARNING: There are active mounts in the installation environment probably"
		show_error "         because of an active preparation session. The execution will be"
		show_error "         terminated in order to prevent damage to the instllation environment"
		exit 5
	fi	
}

function cleanup_mounts() {
	if grep "${TARGET}/chroot" /proc/mounts; then
		# let's try to unmount them
		for MOUNT_POINT in $(grep "${TARGET}/chroot" /proc/mounts | awk '{print $2}'); do
			umount ${MOUNT_POINT} 2> /dev/null
		done
	fi
	if [ -z $1 ]; then
		SHELL_REPEAT=3
	else
		SHELL_REPEAT=$(($1))
	fi
	while grep "${TARGET}/chroot" /proc/mounts > /dev/null; do
		echo >&2
		show_error "WARNING: There are some active mounts in the installation environment that"
		show_error "         cannot be unmounted automatically because probably they are still"
		show_error "         in use by some running process."
		show_error "         Following you get some useful information for solving the problem"
		show_error "         manually."
		echo >&2
		echo "Active filesystem mounts" >&2
		echo "--------------------------------" >&2
		grep "${TARGET}/chroot" /proc/mounts | awk '{print $2}' >&2
		echo >&2
		echo "Active processes having open handles on the mountpoints" >&2
		echo "-------------------------------------------------------" >&2
		for MOUNT_POINT in $(grep "${TARGET}/chroot" /proc/mounts | awk '{print $2}'); do
			lsof | grep ${MOUNT_POINT} >&2
		done
		
		if [ ${SHELL_REPEAT} -lt 1 ]; then
			echo >&2
			echo "Please try to unmount them manually before continuing or reboot." >&2
			exit 1
		fi
		
		echo "A chroot shell into the target environment will be launched for you" >&2
		(( SHELL_REPEAT-- ))
		if [ ${SHELL_REPEAT} -lt 1 ]; then
			echo "so that you may solve the problem." >&2
		else
			echo "so that you may solve the problem. Upon exiting the shell, the dismount" >&2
			echo "will be attempted again." >&2
		fi
		echo "ENTERING CHROOT SHELL...." >&2
		mount_special		
		export debian_chroot="${TARGET} Environment"
		chroot "${TARGET}/chroot" /bin/bash

		if grep "${TARGET}/chroot" /proc/mounts > /dev/null; then
			# trying again to dismount
			umount_special 2> /dev/null
			for MOUNT_POINT in $(grep "${TARGET}/chroot" /proc/mounts | awk '{print $2}'); do
				umount ${MOUNT_POINT} 2> /dev/null
			done
		fi
	done
}


function find_environment() {
	if [ $# -lt 1 ]; then
		# no environment name specified. It must be here....
		test_environment "$(pwd)"
		TARGET="$(pwd)"
	elif [ "${1:0:1}" = "/" ]; then
		# absolute path specified
		test_environment "$1"
		TARGET="$1"
	elif [ -d "$(pwd)/$1" ]; then
		# specified environment under the current directory?
		test_environment "$(pwd)/$1"
		TARGET="$(pwd)/$1"
	elif [ -d "${UIC_WORKDIR}/$1" ]; then
		# specified environment under the default working directory?
		test_environment "${UIC_WORKDIR}/$1"
		TARGET="${UIC_WORKDIR}/$1"
	else
		show_error "Environment $1 does not exist"
		exit 2
	fi
	TARGETNAME=$(basename ${TARGET})
	TARGETPATH=$(dirname ${TARGET})
}

function test_environment() {
	if [ ! -d "$1" ]; then
		show_error "Environment $1 does not exist"
		exit 1
	fi

	if [ ! -f "$1/uictpl.conf" ]; then
		show_error "Environment $1 does not contain a configuration file"
		exit 1
	fi

	if [ ! -d "$1/files" ]; then
		show_error "Environment $1 is invalid"
		exit 1
	fi

#	if [ $(expr match "$1" '.*\/.*') -ne 0 ]; then
#		show_error "Target $1 cannot be a path"
#		exit 1
#	fi
}

function test_environment_empty() {
	if [ ! -d "${TARGET}/chroot" ]; then
		show_error "Installation environment is empty. Use 'uic create' to create a new one."
		exit 1
	fi
	if [ $(find "${TARGET}/chroot" | wc -l) -lt 2 ]; then
		show_error "Installation environment is empty. Use 'uic create' to create a new one."
		exit 1
	fi
}

function test_environment_configuration() {
	if [ -z "${UIC_SRCNAME}" ]; then
		show_error "UIC_SRCNAME missing in environment configuration file"
		exit 1
	fi
	if [ -z "${UIC_SRCVERSION}" ]; then
		show_error "UIC_SRCVERSION missing in environment configuration file"
		exit 1
	fi
	if [ -z "${UIC_ARCH}" ]; then
		show_error "UIC_ARCH missing in environment configuration file"
		exit 1
	fi
	if [ -z "${UIC_RELEASE}" ]; then
		show_error "UIC_RELEASE missing in environment configuration file"
		exit 1
	fi
	if [ -z "${UIC_REPOSITORY}" ]; then
		show_error "UIC_REPOSITORY missing in environment configuration file"
		exit 1
	fi
	if [ -z "${UIC_KERNEL}" ]; then
		show_error "UIC_KERNEL missing in environment configuration file"
		exit 1
	fi
	if [ -z "${UIC_SOFTWARE}" ]; then
		show_error "UIC_SOFTWARE missing in environment configuration file"
		exit 1
	fi
	if [ -z "${UIC_RECONFIGURE}" ]; then
		show_error "UIC_RECONFIGURE missing in environment configuration file"
		exit 1
	fi
	if [ -z "${UIC_ROOTPASSWORD}" ]; then
		show_error "UIC_ROOTPASSWORD missing in environment configuration file"
		exit 1
	fi
}

function test_builder_compatibility() {
	MY_ARCH=$(dpkg-query -W -f='${Architecture}\n' dpkg)
	if [ "${MY_ARCH}" = "${UIC_ARCH}" ]; then
		show_verbose 2 "Target has the same architecture (${MY_ARCH})"
		return 0
	fi
	case "${MY_ARCH}" in
	"amd64")	if [ "${UIC_ARCH}" = "i386" ]; then
				show_verbose 2 "Target has a compatible architecture"
				return 0
			fi
			;;
	esac
	show_error "Target architecture ${UIC_ARCH} not compatible with ${MY_ARCH}"
	exit 3;
}

function cleanup_apt_cache() {
	show_verbose 2 "Cleaning up APT cache"
	if [ -z "$1" ]; then
		apt-get clean
	else
		chroot "$1" apt-get clean
	fi
}

function cleanup_apt_all() {
	show_verbose 2 "Cleaning up all APT files"
	rm -f $1/var/lib/apt/cdroms.list~
	rm -rf $1/var/lib/apt/lists/
	mkdir -p $1/var/lib/apt/lists/partial
	touch $1/var/lib/apt/lists/partial/.delete-me-later
	rm -rf $1/var/cache/apt
	mkdir -p $1/var/cache/apt/archives/partial
}

function cleanup_log_all() {
	show_verbose 2 "Cleaning up log files"
	logfiles="$(find $1/var/log -name '*.[0-9]*')"
	logfiles="$logfiles $(find $1/var/log -name '*.gz')"
	for logfile in $logfiles; do
		show_verbose 3 "Deleting $logfile"
	        rm -f "$logfile"
	done
	for logfile in $(find "$1/var/log" -type f); do
		show_verbose 3 "Truncating $logfile"
		>"$logfile"
	done
}

function cleanup_history() {
	show_verbose 2 "Removing history files of user root"
	rm -f $1/root/.*_history
}

function cleanup_fixed_devices() {
	show_verbose 2 "Cleaning up persistent device assignments"
	rm -f $1/etc/udev/rules.d/70-persistent-cd.rules
	rm -f $1/etc/udev/rules.d/70-persistent-net.rules
}

function cleanup_all() {
	cleanup_apt_cache $1
	cleanup_apt_all $1
	cleanup_log_all $1
	cleanup_history $1
	cleanup_fixed_devices $1
}

function cleanup_environment() {
	show_verbose 1 "Cleaning up installation environment..."
	cleanup_all "${TARGET}/chroot"
}

function verify_environment() {
	if [ -z "$1" ]; then
		TESTPATH=${TARGET}
	else
		TESTPATH=${1}
	fi
	if [ ! -f "${TESTPATH}/uictpl.md5" ]; then
		show_verbose 1 "No integrity checksums found."
		return 0;
	fi
	show_verbose 2 "Testing integrity checksums"
	MD5TEMP=$(mktemp)
	SEDFORMULA="s/ \*/ \*"$(echo -n "$TESTPATH" | sed -e 's/\//\\\//g')"\//g" 
	sed -e "$SEDFORMULA" < "${TESTPATH}/uictpl.md5" > "$MD5TEMP"
	md5sum --quiet -c "$MD5TEMP"
	if [ $? -ne 0 ]; then
		show_warning "Environment integrity error."
		rm "$MD5TEMP"
		return 1
	fi
	rm "$MD5TEMP"
	return 0
}

function test_prereq() {
	if [ -z $(which debootstrap) ]; then
		show_error "Package debootstrap not installed."
		exit 1
	fi
}

function call_hook() {
	if [ -z "$1" ]; then
		return 0
	fi
	show_verbose 3 "Searching hook $1..."
	if [ -x "${TARGET}/hooks/$1" ]; then
		show_verbose 2 "Executing hook $1..."
		source "${TARGET}/hooks/$1"
		test_exec $1
	fi
}

function call_chroot_hook() {
	if [ -z "$1" ]; then
		return 0
	fi
	show_verbose 3 "Searching chroot hook $1..."
	if [ -x "${TARGET}/hooks/$1" ]; then
		show_verbose 2 "Copying chroot hook $1 into the installation environment..."
		cp "${TARGET}/hooks/$1" "${TARGET}/chroot/tmp"
		show_verbose 2 "Executing hook $1..."
		chroot "$TARGET/chroot" "/tmp/$1"
		test_exec $1
		show_verbose 2 "Removing chroot hook $1 from the installation environment..."
		rm "${TARGET}/chroot/tmp/$1"
	fi
}

function apply_customizations() {
	if [ -z "$1" ]; then
		CUST_SUBDIR="files"
	else
		CUST_SUBDIR="$1"
	fi
	show_verbose 1 "Applying customizations to the target installation environment..."
	call_hook pre_customization
	call_chroot_hook chroot_pre_customization
	cp -a "$TARGET/$CUST_SUBDIR/." "$TARGET/chroot/"
	if [ -f "${TARGET}/$CUST_SUBDIR.remove" ]; then
		xargs -r -a "${TARGET}/$CUST_SUBDIR.remove" rm -rf
	fi
	create_minimal_files
	call_chroot_hook chroot_post_customization
	call_hook post_customization
}

function create_minimal_files() {
	# locale
	if [ ! -f "$TARGET/chroot/var/lib/locales/supported.d/local" ]; then
		echo -e "en_US.UTF-8 UTF-8" > "$TARGET/chroot/var/lib/locales/supported.d/local"
	fi
	# hostname
	if [ ! -f "$TARGET/chroot/etc/hostname" ]; then
		echo $UIC_SRCNAME > "$TARGET/chroot/etc/hostname"
	fi
	# dns resolution
	if [ ! -f "$TARGET/chroot/etc/resolv.conf" ]; then
		echo -e "nameserver 208.67.222.222\nnameserver 208.67.220.220" > "$TARGET/chroot/etc/resolv.conf"
	fi
	# file system table
	if [ ! -f "$TARGET/chroot/etc/fstab" ]; then
		echo -e "# /etc/fstab: static file system information." > "$TARGET/chroot/etc/fstab"
		echo -e "#" >> "$TARGET/chroot/etc/fstab"
		echo -e "# <file system>\t\t\t<mount point>\t<type>\t<options>\t\t\t<dump>\t<pass>" >> "$TARGET/chroot/etc/fstab"
		echo -e "proc\t\t\t\t/proc\t\tproc\tdefaults\t\t\t0\t0" >> "$TARGET/chroot/etc/fstab"
		echo -e "" >> "$TARGET/chroot/etc/fstab"
		echo -e "tmpfs\t\t\t\t/tmp\t\ttmpfs\tdefaults,noatime\t\t0\t0" >> "$TARGET/chroot/etc/fstab"
		echo -e "tmpfs\t\t\t\t/var/tmp\ttmpfs\tdefaults,noatime\t\t0\t0" >> "$TARGET/chroot/etc/fstab"
	fi
}

function get_filtered_repository() {
	if [ -z "${UIC_APTPROXY}" ]; then
		echo ${UIC_REPOSITORY}
	else
		echo ${UIC_REPOSITORY} | sed -e "s/http:\/\/[^\/]*/http:\/\/${UIC_APTPROXY}/g"
	fi
}

function init_apt_proxy() {
	if [ -z "${UIC_APTPROXY}" ]; then
		return 0
	fi
	if [ -f "$TARGET/chroot/etc/apt/sources.list" ]; then
		mv "$TARGET/chroot/etc/apt/sources.list" "$TARGET/chroot/etc/apt/sources.list.BACKUP"
		sed -e "s/http:\/\/[^\/]*/http:\/\/${UIC_APTPROXY}/g" < "$TARGET/chroot/etc/apt/sources.list.BACKUP" > "$TARGET/chroot/etc/apt/sources.list"
	fi
}

function exit_apt_proxy() {
	if [ -f "$TARGET/chroot/etc/apt/sources.list.BACKUP" ]; then
		mv "$TARGET/chroot/etc/apt/sources.list.BACKUP" "$TARGET/chroot/etc/apt/sources.list"
	fi
}
